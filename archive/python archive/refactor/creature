class Creature(TombEntity):
	def __init__(self):
		super().__init__()
		self.symbol = '&'
		self._name = "creeping feature"
		self._image = "other"
		self.task = None
		self.ai = WanderingAI(self)
		self.equipment = Equipment(self)
		self.mood = moods["neutral"]
		self.toughness = 3
		self.wounds = 0
		self.prowess = 1
		self.minions = []
		self.sight_range = 8
		self.leaves_corpse = True
		
	def spend_action(self):
		pass
		
	def explore(self):
		for square in Tomb.zone.subgrid([self.x-self.sight_range,self.y-self.sight_range,self.z-self.sight_range],[self.x+self.sight_range,self.y+self.sight_range,self.z+self.sight_range]):
			if self.can_see(square,self.sight_range):
				square.explored = True
				square.visible = True	
				
		
	def doAI(self):
		self.ai.go()
	
	def build_wall(self, target):
		if target.solid():
			Tomb.gui.push_message("There is already a wall there.")
			return

		enough = 5
		from .items import StackedStoneItem, StoneItem
		stacked_tally = 0
		succeed = False
	
		for item in target.items:
			if isinstance(item,StackedStoneItem):
				stacked_tally += item.n
				#if there are at least ten, complete the wall
				if stacked_tally >= enough:
					for item in target.items:
						if isinstance(item,StackedStoneItem):
							item.destroy()
					target.material = 2 #cobblestone
					target.durability = 10
					succeed = True
					Tomb.gui.push_message(self.name + " completes a wall.")
					if self.square == target and not self.square.ceiling().solid():
						self.move_to(self.x,self.y,self.z+1)
		if not succeed:
			for item in self.items:
				if isinstance(item,StoneItem):
					Tomb.gui.push_message(self.name + " stacks a stone on " + target.name + ".")
					if item.n == 1:
						item.destroy()
					else:
						item.n-=1
					target.items.put(StackedStoneItem())
					succeed = True
					break
		if succeed:
			self.spend_action()
		else:
			Tomb.gui.push_message("No stone available.")
		
	def fall(self):
		floor = Tomb.zone.find_floor(self.x, self.y, self.z)
		self.move_to(self.x,self.y,floor)
		Tomb.gui.push_message(self.name + " falls to " + self.square.name)
		
	def dig(self, square):
		if square.solid():
			Tomb.gui.push_message(self.name + " digs into " + square.name + ".")
			square.dismantle(1)
			self.spend_action()
	
	def dismantle(self, feature):
		Tomb.gui.push_message(self.name + " chips away at " + feature.name + ".")
		feature.dismantle(1)
		self.spend_action()
			
	def die(self):
		Tomb.publish(DeathEvent(self))
		
	def mourn(self, event):
		if event.creature in self.minions:
			self.minions.remove(event.creature)
			Tomb.gui.push_message(self.name + " mourns the death of " + event.creature.name + ".")
			
	def is_hostile(self, creature):
		if self.mood == moods["loyal"]:
			if creature.mood in (moods["hostile"],moods["hateful"],moods["berserk"]):
				return True
		elif self.mood == moods["friendly"]:
			if creature.mood in (moods["hateful"],moods["berserk"]):
				return True
		elif self.mood == moods["neutral"]:
			if creature.mood in (moods["hateful"],moods["berserk"]):
				return True
		elif self.mood == moods["angry"]:
			if creature.mood in (moods["loyal"],moods["hostile"],moods["hateful"],moods["berserk"]):
				return True
		elif self.mood == moods["hostile"]:
			if creature.mood in (moods["loyal"],moods["friendly"]):
				return True
		elif self.mood == moods["hateful"]:
			if not isinstance(self,creature.__class__):
				return True
		elif self.mood == moods["berserk"]:
			return True
		return False
		
	def is_friendly(self, creature):
		if self.mood == moods["loyal"]:
			if creature.mood in (moods["loyal"],moods["friendly"]):
				return True
		elif self.mood == moods["friendly"]:
			if creature.mood in (moods["loyal"],moods["friendly"]):
				return True
		elif self.mood == moods["neutral"]:
			if creature.mood in (moods["neutral"],moods["angry"]):
				return True
		elif self.mood == moods["angry"]:
			if creature.mood in (moods["neutral"],moods["angry"]):
				return True
		elif self.mood == moods["hostile"]:
			if creature.mood == moods["hostile"]:
				return True
		elif self.mood == moods["hateful"]:
			if isinstance(self,creature.__class__):
				return True
		elif self.mood == moods["berserk"]:
			return False
		return False
		
		
	def displace(self, target):
		square1 = self.square
		square2 = target.square
		square2.creature = self
		square1.creature = target
		self.send_message(self.name + " displaces " + target.name + ".")
		self.spend_action()
	
	def attack(self, target):
		from .tomb import AttackEvent
		attack = AttackEvent(self,target)
		Tomb.publish(attack)
		self.spend_action()
		
	def try_move(self,x,y,z):
		#it would be nice if NPCs tried a little more persistently
		square = Tomb.zone.grid(self.x+x,self.y+y,self.z+z)
		target = square.level_ground()
		if not target:
			if square.solid():
				self.send_message(self.name + " bumps into " + square.name + ".")
			else:
				self.send_message(self.name + " avoids falling into pit at " + square.name + ".")
			self.do_nothing()
			return False
			
		if target==self.square:
			return False
			
		if target.creature:
			if self.is_hostile(target.creature):
				self.attack(target.creature)
				#not sure what I should return here...
			elif self.is_friendly(target.creature):
				if self in target.creature.minions:
					self.send_message(self.name + " would like to move past " + target.creature.name + ".")
					self.do_nothing()
					return False
				else:
					self.displace(target.creature)
					return True
			else:
				self.send_message(self.name + " bumps into " + target.creature.name + ".")
				self.do_nothing()
				return False
		elif target.feature and target.feature.solid:
			self.send_message(self.name + " bumps into " + target.feature.name + ".")
			self.do_nothing()
			return False
		else:
			self.do_move(target.x,target.y,target.z)
			return True
	
		
	def do_move(self,x,y,z):
		self.move_to(x,y,z)
		self.spend_action()
		
	def move_to(self,x,y,z):
		self.square.creature = None
		Tomb.zone.grid(x,y,z).creature = self
		
	def get(self):
		if self.square.items:
			item = self.square.items[-1]
			self.square.items.take(item)
			item = item.pickup()
			self.items.put(item)
			#from .tomb import Tomb
			Tomb.gui.push_message(self.name + " picks up " + item.name + ".")
			self.spend_action()
		
	def drop(self):
		if self.items:
			item = self.items[-1]
			self.items.take(item)
			self.square.items.put(item)
			#from .tomb import Tomb
			Tomb.gui.push_message(self.name + " drops " + item.name + ".")
			self.spend_action()
			
	def do_nothing(self):
		pass