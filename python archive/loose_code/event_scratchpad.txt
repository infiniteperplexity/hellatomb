#metaclass
class EnumerableClass(type):
    def __init__(cls, name, bases, nmspc):
        super(EnumerableClass, cls).__init__(name, bases, nmspc)
        if not hasattr(cls, 'registry'):
            cls.registry = {}
            
        cls.registry.pop(bases[0].__name__, None)
        n = len(cls.registry)
        if cls.__name__ != bases[0].__name__ and bases[0].__name__ != "object":
        	cls.registry[cls.__name__] = n
        	setattr(bases[0], cls.__name__, n)
        	
        	
class Event(object, metaclass = EnumerableClass):
	def publish(self):
		Tomb.events.publish(self)

class TurnEvent(Event):
	def __init__(self): pass
	
class EventHandler(object):
	def __init__(self):
		self.listeners = {}
		for key in Event.registry:
			self.listeners[key] = []
			
	def publish(self, event):
		for listener in self.listeners[event.__class__.__name__]:
			listener.listen(event)
	
		
#mixin
class EventListener(object):
	def subscribe(self, etype):
		Tomb.events.listeners[etype].append(self)
		
	def unsubscribe(self, etype):
		Tomb.events.listeners[etype].remove(self)
		
	def listen(self, event):
		getattr(self,event.__class__.__name__)(event)

		
class Creature(EventListener):
	def TurnEvent(self, event):
		print("a turn passed.")
		self.unsubscribe(TurnEvent)

Creature().listen(TurnEvent())